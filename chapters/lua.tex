
\section{Programmeringsspråket Lua}

Lua är ett skriptspråk som kombinerar procedurell programmering med
funktionalitet från det funktionella paradigmet och det objektorienterade
paradigmet \citep{luaimp}.

Luas mål är att använda en enkel syntax med en liten grupp av kostrukturer, att
vara snabbt såväl i kompilering som exekvering, att kunna köras på så många
platformer som möjligt och slutligen att vara effektigt för inbäddning i
proram. Dessa mål anses vara uppådda enligt \cite{luaimp}.

Utgående från dessa mål är Lua ett bra alternativ för konfigurationsspråk och
används idag som sådant i bland annat Adobes Photoshop Lightroom och World of
Warcraft \citep{lua}.

\subsection{Funktionalitet}

Trots att ett av Luas mål är dess enkelhet har språket en stor mängd
funktionalitet som fås av dess flexibilitet och val av datastruktur.

En överblick av Luas funktionalitet är \citep{luaimp}:

\begin{description}
  \item[Dynamisk typning] \hfill \\
    Lua består av 8 datatyper: \textit{nil, boolean, number, string, table,
    function}. Språket använder sig dock av dynamisk typning vilket innebär att
    variabler kan referera till vilken datatyp som helst, och därmed behöver
    programmeren inte heller definiera typen vid variabel initialisering.

  \item[Första ordningens datatyper] \hfill \\
    Alla Luas datatyper är värden av första ordningen. Detta innebär att
    programmeraren kan använda sig av logik från funktionell programmering och
    därmed använda sig av funktioner och tabeller som returvärden och
    funktionsargument.

  \item[Associativ array] \hfill \\
    Lua har enbart en datastruktur, tabeller, och detta är en associativ
    array. En associativ array är dynamiskt växande, kan indexeras av vilken
    datatyp som helst (förutom \textit{nil}) och kan också hålla vilket värde
    som helst. Med hjälp av denna flexibilitet kan tabeller användas både som
    en array och som en hashtabell.

  \item[Arv] \hfill \\
    Trots att Lua inte är ett strikt objektorienterat språk kan klasser och
    arv implementeras med metatabeller och metametoder. Varje värde i Lua har
    dessa och de kan användas för att bygga upp ett prototyp arv likt
    JavaScript.

  \item[Closures] \hfill \\
    Lua har lexikalt scope vilket tillsammans med första ordningens funktioner
    möjliggör användningen av closures. Under exekvering av en funktion skapar
    Lua en closure om innehåller referenser till dess inrevariabler, dess
    miljö samt dess yttrevariabler. Detta möjliggör ytterligare funktionalitet
    för funktionell programmering.
\end{description}

\subsection{Grammatik}

Luas grammatik existerar i en EBNF notation som inkluderats i dess
ursprungliga form i Bilaga 1.

När Lua övergick från en genererad parser till en handskriven rekursivt
nedstigande parser i version 3.0 \citep{luaimp} gjordes dock några
förändringar till grammatiken som inte dokumenterats. Uttrycksparsern har
exempelvis omstrukturerats totalt för att kunna beskrivas som en LL(1) och
vara effektiv \citep[s. 175]{bf09}.

Vid analys av grammatiken kan det konstateras att mycket av grammatiken går att
implementera i LL(1) utan större förändringar. De problem som uppstår är en
vänster rekursion i uttrycksregeln samt ett lookahead problem för att
identifiera variabel deklarationer från funktionskallelser. Dessa problem
kommer hanteras vid implementationsbeskrivningen för parser komponenterna.

% vim: set tw=78:ts=2:sw=2:et:fdm=marker:wrap:wm=78:ft=tex
% vim: spell spelllang=sv
